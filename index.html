<!DOCTYPE html>
<html style="touch-action:pan-y">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,viewport-fit=cover">
    <title>Astrativ (Dynamically-typed Language)</title>
  </head>
  <body style="background: black; margin: 0px; padding: 0px; font-size: 16px; color: white; font-family: monospace;">
    <div id="output-wrapper">
      <div style="margin: 8px; padding: 0px;">
        <div id="hint-for-nonmobile">Ctrl+D to execute the input</div>
        <div id="output" style="white-space: pre-wrap; word-break: break-all;"></div>
        <textarea id="script-input" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="border: 0px; outline: 0px; background: black; color: white; margin: 0px; padding: 0px; font-family: monospace; font-size: 16px; width: 100%; resize: none;"></textarea>
        <form id="script-input-form-for-mobile" style="display:none; margin: 0px; padding: 0px; line-height: 0px;">
          <input id="script-input-for-mobile" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="border: 0px; outline: 0px; background: black; color: white; box-sizing: border-box; margin: 0px; padding: 0px; font-family: monospace; font-size: 16px; width: 100%;">
        </form>
      </div>
    </div>
    <script type="text/javascript">
      ~async function() {
          const output = document.getElementById("output");
          const outputWrapper = document.getElementById("output-wrapper");
          const isMobile = /(iPhone|iPad|iPod|Android)/i.test(navigator.userAgent) || new URLSearchParams(location.search).has("mobile");
          const input = document.getElementById(isMobile ? "script-input-for-mobile" : "script-input");
          const inputForm = document.getElementById("script-input-form-for-mobile");

          if (isMobile) {
              inputForm.style.display = "";
              document.getElementById("script-input").style.display = "none";
              document.getElementById("hint-for-nonmobile").style.display = "none";
          }

          const scrollToTheEnd = () => requestAnimationFrame(() => {
              const body = document.body, html = document.documentElement;
              window.scrollTo({
                  top: Math.max(0, Math.max(window.innerHeight, body.clientHeight, body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight) - window.innerHeight),
                  behavior: "instant"
              });
          });
          const inputHistory = [];
          let inputHistoryIndex = 0;
          if (!isMobile) {
              input.addEventListener("input", () => {
                  input.style.height = "3px";
                  input.style.height = input.scrollHeight + "px";
              });
              window.addEventListener("resize", () => {
                  input.style.height = "3px";
                  input.style.height = input.scrollHeight + "px";
              });
          }

          inputForm.addEventListener("submit", e => {
              e.preventDefault();
              if (isMobile) evalInput();
          });

          function evalInput() {
              const inputValue = `${input.value ?? ""}`;
              if (!inputValue.trim()) return;
              inputHistory[inputHistory.length] = inputValue;
              inputHistoryIndex = inputHistory.length;
              const newOutput = document.createElement("div");
              newOutput.textContent = inputValue;
              output.appendChild(newOutput);
              scrollToTheEnd();

              input.value = "";

              executeAstrativ(inputValue);
          }

          document.documentElement.addEventListener("keydown", e => {
              if (!isMobile && e.ctrlKey && e.code === "KeyD") {
                  e.preventDefault();
                  evalInput();
                  return;
              }
              if (e.altKey || e.metaKey || e.ctrlKey) return;
              if (e.code === "ArrowUp") {
                  e.preventDefault();
                  if (inputHistoryIndex >= 1) {
                      inputHistoryIndex--;
                      input.value = inputHistory[inputHistoryIndex];
                      scrollToTheEnd();
                  }
                  return;
              }
              if (e.code === "ArrowDown") {
                  e.preventDefault();
                  if (inputHistory.length - 1 > inputHistoryIndex) {
                      inputHistoryIndex++;
                      input.value = inputHistory[inputHistoryIndex];
                      scrollToTheEnd();
                  }
                  return;
              }
              input.focus();
          });
          window.addEventListener("load", () => {
              input.focus();
          });
          document.documentElement.addEventListener("click", e => {
              if (outputWrapper.contains(e.target)) return;
              if (getSelection().type === "Range") return;
              input.focus();
          });

          const bytes = await fetch("./astrativ.wasm").then(r => r.arrayBuffer());
          const mod = new WebAssembly.Module(bytes);
          const instance = new WebAssembly.Instance(mod, {
              wbg: {
                  __wbindgen_string_new(arg0, arg1) {
                      return addHeapObject(getStringFromWasm0(arg0, arg1));
                  },
                  __wbg_error_f851667af71bcfc6(arg0, arg1) {
                    let deferred0_0;
                    let deferred0_1;
                    try {
                      deferred0_0 = arg0;
                      deferred0_1 = arg1;
                      console.error(getStringFromWasm0(arg0, arg1));
                    } finally {
                      instance.exports.__wbindgen_free(deferred0_0, deferred0_1, 1);
                    }
                  },
                  __wbg_new_abda76e883ba8a5f() {
                    const ret = new Error();
                    return addHeapObject(ret);
                  },
                  __wbg_stack_658279fe44541cf6(arg0, arg1) {
                    const ret = getObject(arg1).stack;
                    const ptr1 = passStringToWasm0(ret, instance.exports.__wbindgen_malloc, instance.exports.__wbindgen_realloc);
                    const len1 = WASM_VECTOR_LEN;
                    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
                    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
                  },
                  __wbindgen_object_drop_ref(arg0) {
                      takeObject(arg0);
                  },
                  __wbg_log_b103404cc5920657(arg0) {
                      const newOutput = document.createElement("div");
                      newOutput.textContent = `${getObject(arg0)}`;
                      output.appendChild(newOutput);
                      scrollToTheEnd();
                  },
                  __wbg_now_b7a162010a9e75b4() {
                      return Date.now();
                  },
                  __wbindgen_throw(arg0, arg1) {
                      throw new Error(getStringFromWasm0(arg0, arg1));
                  },
              }
          });

          const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });
          cachedTextDecoder.decode();

          let cachedUint8ArrayMemory0 = null;

          function getUint8ArrayMemory0() {
              if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
                  cachedUint8ArrayMemory0 = new Uint8Array(instance.exports.memory.buffer);
              }
              return cachedUint8ArrayMemory0;
          }

          let cachedDataViewMemory0 = null;

          function getDataViewMemory0() {
            if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== instance.exports.memory.buffer)) {
              cachedDataViewMemory0 = new DataView(instance.exports.memory.buffer);
            }
            return cachedDataViewMemory0;
          }

          function getStringFromWasm0(ptr, len) {
              ptr = ptr >>> 0;
              return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
          }

          const heap = new Array(128).fill(undefined);

          heap.push(undefined, null, true, false);

          let heap_next = heap.length;

          function addHeapObject(obj) {
              if (heap_next === heap.length) heap.push(heap.length + 1);
              const idx = heap_next;
              heap_next = heap[idx];

              heap[idx] = obj;
              return idx;
          }

          function getObject(idx) { return heap[idx]; }

          function dropObject(idx) {
              if (idx < 132) return;
              heap[idx] = heap_next;
              heap_next = idx;
          }

          function takeObject(idx) {
              const ret = getObject(idx);
              dropObject(idx);
              return ret;
          }

          let WASM_VECTOR_LEN = 0;

          const cachedTextEncoder = new TextEncoder('utf-8');
          function encodeString(arg, view) {
              const buf = cachedTextEncoder.encode(arg);
              view.set(buf);
              return {
                  read: arg.length,
                  written: buf.length
              };
          }
          function passStringToWasm0(arg, malloc, realloc) {
              if (realloc === undefined) {
                  const buf = cachedTextEncoder.encode(arg);
                  const ptr = malloc(buf.length, 1) >>> 0;
                  getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
                  WASM_VECTOR_LEN = buf.length;
                  return ptr;
              }
              let len = arg.length;
              let ptr = malloc(len, 1) >>> 0;
              const mem = getUint8ArrayMemory0();
              let offset = 0;
              for (; offset < len; offset++) {
                  const code = arg.charCodeAt(offset);
                  if (code > 0x7F) break;
                  mem[ptr + offset] = code;
              }
              if (offset !== len) {
                  if (offset !== 0) {
                      arg = arg.slice(offset);
                  }
                  ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
                  const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
                  const ret = encodeString(arg, view);
                  offset += ret.written;
                  ptr = realloc(ptr, len, offset, 1) >>> 0;
              }
              WASM_VECTOR_LEN = offset;
              return ptr;
          }

          const globals = instance.exports.initialize_context() >>> 0;
          function executeAstrativ(source_code) {
              try {
                  const ptr0 = passStringToWasm0(source_code, instance.exports.__wbindgen_malloc, instance.exports.__wbindgen_realloc);
                  const len0 = WASM_VECTOR_LEN;
                  instance.exports.execute(globals, ptr0, len0);
              } catch(e) {
                  const newOutput = document.createElement("div");
                  newOutput.style.color = "red";
                  newOutput.textContent = `${e}`;
                  output.appendChild(newOutput);
                  scrollToTheEnd();
              }
          }
      }();
      if ("serviceWorker" in navigator) navigator.serviceWorker.register("./sw.js");
    </script>
  </body>
</html>
